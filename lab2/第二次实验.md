# SDN-实验二

> **计算机96      徐亮           学号：2196114661**

## 一. 实验目的

- 学习利用 `ryu.topology.api` 发现网络拓扑。 
- 学习利用 LLDP 和 Echo 数据包测量链路时延。 
- 学习计算基于跳数和基于时延的最短路由。 
- 学习设计能够容忍链路故障的路由策略。 
- 分析网络集中式控制与分布式控制的差异，思考集中式网络的得与失。

## 二. 实验环境

- 实验环境： `VWWare Ubuntu 20.04 LTS` 

- 实验工具： `Mininet` 、 `Ryu` 、 `WireShark` 等。

## 三. 实验原理

本次实验的主要思想可以分为以下几个方面：

- 获取网络拓扑状态图；
- 获取各节点之间的时延；
- 计算各点之间基于时延的最短路径；

接下来会对每一方面的原理进行详细解释。

### 1. 获取网络拓扑

控制器首先要获取网络的拓扑结构，才能够对网络进行各种测量分析，网络拓扑主要包括主机、链路和 交换机的相关信息。

在SDN中，我们可以调用 ryu.topology.api 中的 get_all_host 、 get_all_link 、 get_all_switch 等函数，就可以获得全局拓扑的信息。

关键部分代码可以如下所示：

```python
def _get_topology(self):
	while True:
		hosts = get_all_host(self)
		switches = get_all_switch(self)	
		links = get_all_link(self)
		hub.sleep(2)
```

拓扑的发现比较容易理解。控制器通过将携带dpid+port_no信息的LLDP数据包从对应端口packet_out出去，然后LLDP数据包被对端交换机Packet_in到控制器，最后再由控制器结合Packet_in消息报头的DPID和in_port和LLDP报文中的DPID和Port_no从而得出一条链路信息。依次类推，控制器可以发现全部的链路信息，从而发现网络拓扑。

### 2. 获取链路时延

获取两台主机之间的链路时延比较简单，可以直接测量，但是获取交换机结点之间的时延则需要一些计算才行。

1. 控制器向交换机A下发一个Packet_out报文。报文的数据段携带了任意一个约定好的协议报文，其报文的数据段携带了控制器下发报文时的时间戳。Packet_out报文的动作指示交换机将其泛洪或者转发到某端口。

2. 交换机B收到了交换机A发送过来的数据包，无法匹配对应流表项，从而packet_in到控制器。控制器接收到这个数据包之后，和当下时间相减，得到时间差T1。T1约等于数据包从控制器到交换机A + 交换机A到交换机B + 交换机B到控制器的时延。

3. 同理，控制器向交换机B发送一个类似的报文。然后控制器从交换机A收到Packet_in报文，记录下时间差T2。所以T1+T2=控制器到交换机A的RTT+控制器到交换机B的RTT+交换机A到交换机B的时延RTT。

4. 控制器向交换机A和交换机B分别发送带有时间戳的Echo request。交换机收到之后即刻回复携带echo request时间戳的echo reply消息。所以控制器可以通过Echo reply的时间戳减去Echo reply携带的时间，从而得到对应交换机和控制器之间的RTT。通过这种方法测得控制器到交换机A,B的RTT分别为Ta，Tb。

5. `T1+T2-Ta-Tb`则得到交换机A到交换机B的RTT。假设往返时间一样，则交换机A到交换机B的链路时延为：
    $$
    （T1+T2-Ta-Tb）/2
    $$

这种方法可以相对准确地测试到链路的实验，无法计算而忽略掉的部分时间是数据包在交换机中的处理时延。

### 3. 计算最短路径

建立了拓扑图，将时延作为每一条边的权重后，就可以利用迪杰斯特拉等算法实现最短路径算法。这里我调用networkx API来直接计算，主要思路为，通过network_awareness应用来实现网络拓扑资源的感知并计算最短路径，过程如下：

1. 使用networkx的有向图数据结构存储拓扑信息；

2. 使用networkx提供的`shortest_simple_paths`函数来计算最短路径。其函数参数信息为：

    `shortest_simple_paths(G, source, target, weight=None)`

3. 获得最短路径之后，shortest_forwarding应用将完成流表下发等工作，实现基于跳数的最短路径转发应用。

## 四. 实验示例

计算最少跳数路径，也就是将每条边的权重都设置为相同的值，即所有边的权重相同，然后求解最短路径。

关键代码如下：

```python
    def get_out_port(self, datapath, src, dst, in_port):
        dpid = datapath.id
 
        # 开始时，各个主机可能在图中不存在，因为开始ryu只获取了交换机的dpid，并不知道各主机的信息，
        # 所以需要将主机存入图中
        if src not in self.G:
            # 添加结点和边
            self.G.add_node(src)
            self.G.add_edge(dpid, src, attr_dict={'port': in_port})
            self.G.add_edge(src, dpid)
 
		# 计算最短路径
        if dst in self.G:
            path = nx.shortest_path(self.G, src, dst)
            #设置节点跳数
            next_hop = path[path.index(dpid) + 1]
            out_port = self.G[dpid][next_hop]['attr_dict']['port']
            print(path)
        else:
            out_port = datapath.ofproto.OFPP_FLOOD
        return out_port

```

另外要注意的是，跟实验一相同，要记得处理环路风暴的问题。

## 五. 任务一

### 关键代码讲解：

#### 求lldp_delay

根据上述计算链路时延的原理，我们需要计算出LLDP包的时延和echo包的时延。首先我们来计算lldp_delay，其思路就是我们事先将switchs类的内容加上时延，并且利用timestamp来保存lldp包刚发出的时间。等到控制器收到packet_in报文的时候，记录下当前的时间，相减即可得到时间差，也就是lldp_delay。

```python
    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
    def packet_in_handler(self, ev):
        msg = ev.msg
        try:
            dp = msg.datapath
            src_dpid,src_port = LLDPPacket.lldp_parse(msg.data)
            dpid = dp.id
            self.link_info.setdefault(dpid,{})
            self.datapath[dpid] = dp
            if self.switches is None:
                self.switches = lookup_service_brick("switches")
            
            for port in self.switches.ports.keys():
                if src_dpid == port.dpid and src_port == port.port_no:
                    port_data = self.switches.ports[port]
                    timestamp = port_data.timestamp
                    if timestamp:
                        lldpdelay = time.time()-timestamp
                        # calculate the lldp delay
                        self.lldp_delay[(src_dpid, dpid)]=lldpdelay
        except LLDPPacket.LLDPUnknownFormat as e: 
            return
```

#### 求echo_delay

想要求出echo_delay，可以利用echo request包和echo reply包的时间差求解。控制器向交换机s1和交换机s2分别发送带有时间戳的Echo request。交换机收到之后即刻回复携带echo request时间戳的echo reply消息。所以控制器可以通过Echo reply的时间戳减去Echo reply携带的时间，从而得到对应交换机和控制器之间的 RTT，也就求解出来了echo_delay_s1 和 echo_delay_s2 。

```python
    # 发送echo request数据包时，在数据包中记录发出的时间
    def send_echo_request(self):
        while True:
            for datapath in self.datapath.values():
                parser = datapath.ofproto_parser
                data = time.time()
                echo_req = parser.OFPEchoRequest(datapath,data)
                datapath.send_msg(echo_req)
            hub.sleep(SEND_ECHO_REQUEST_INTERVAL)
    
    # 在接收echo_reply数据包时，计算时间差
    @set_ev_cls(ofp_event.EventOFPEchoReply, MAIN_DISPATCHER)
    def echo_reply_handler(self,ev):
        # 计算echo_delay
        echodelay = time.time()-eval(ev.msg.data)
        self.echo_delay[ev.msg.datapath.id] = echodelay
```

#### 计算delay

得到了两交换机之间的lldp_delay和echo_delay，就可以计算交换机之间的时延了。公式为：
$$
delay = (lldp\_delay\_s12 + lldp\_delay\_s21 - echo\_delay\_s1 -
echo\_delay\_s2) / 2
$$
`get_delay`函数如下：

```python
    def get_delay(self,src,dst):
        try:
            sd_lldpdelay = self.lldp_delay[(src,dst)]
            ds_lldpdelay = self.lldp_delay[(dst,src)]
            src_echodelay = self.echo_delay[src]
            dst_echodelay = self.echo_delay[dst]

            # 根据公式计算时延
            delay = (sd_lldpdelay+ds_lldpdelay-src_echodelay-dst_echodelay)/2

            # 测出来时延若为负数则取值为0
            if delay<0:
                delay = 0
            return delay
        except:
            return float('inf')
```

#### 计算最短路径

计算出了时延，则需要将边的权重设置为时延，因此获得拓普的程序当中应该在后面加入代码：

```python
# 计算两节点之间的时延
delay = self.get_delay(link.src.dpid,link.dst.dpid)
# 添加权重为delay
self.topo_map.add_edge(link.src.dpid, link.dst.dpid, delay=delay, is_Host=False)
```

最后在处理packet_in数据包的函数当中加入最短路径的计算，即可求出基于时延的最短路径

```python
# 计算最短路径
dpid_path = self.network_awareness.shortest_path(src_ip, dst_ip,weight=self.weight)
if not dpid_path:
    return
```

### 实验过程

#### 1. 更改Ryu的Switches类

- PortData 记录交换机的端口信息，我们需要增加 self.delay 属性记录上述的 lldp_delay

![image-20220417210008762](https://gitee.com/bright_xu/blog-image/raw/master/202204172100840.png)

- lldp_packet_in_handler() 处理接收到的 LLDP 包，在这里用收到 LLDP 报文的时间戳减去发送时的 时间戳即为 lldp_delay ，由于 LLDP 报文被设计为经一跳后转给控制器，我们可将 lldp_delay 存入发 送 LLDP 包对应的交换机端口。

![image-20220417210052515](https://gitee.com/bright_xu/blog-image/raw/master/202204172100563.png)

- 需重新编译安装 Ryu ，在安装目录下运行 

    `sudo python setup.py install`

![image-20220417210146921](https://gitee.com/bright_xu/blog-image/raw/master/202204172101977.png)

#### 2. 验证结果

首先运行拓扑图：

![image-20220417210434128](https://gitee.com/bright_xu/blog-image/raw/master/202204172104188.png)

然后运行ryu控制器：

![image-20220417210515214](https://gitee.com/bright_xu/blog-image/raw/master/202204172105274.png)

由于每条链路的时延已经被拓扑文件预设好了，所以最终的正确结果应该适合预测值相差不大的，这里用`SDC ping MIT`来验证。如下图：

![image-20220417210530221](https://gitee.com/bright_xu/blog-image/raw/master/202204172105277.png)

可以看到第一次ping是因为节点内没有流表，需要想控制器发出询问，因此花费时间较久，这在实验一已经研究过，不再赘述。后续按照流表中的最短路径走，可见RTT稳定在131ms左右，这与我们预设的值相差不大，误差可能来源于数据包在交换机中的处理时延在不同性能的机器上各有不同。

再查看求出来的最短路径，可以看到与预期的完全一致：

![image-20220417210946866](https://gitee.com/bright_xu/blog-image/raw/master/202204172109910.png)

然后`pingall`检查各主机之间能否通信，全部都能ping通，如下图所示：

![image-20220417221231194](https://gitee.com/bright_xu/blog-image/raw/master/202204172212279.png)

可以打印出路径，检查各节点之间最短路径是否正确，由于路线是双向的，因此只需要从小到大打印一半即可，如下图所示：

![image-20220417232623831](https://gitee.com/bright_xu/blog-image/raw/master/202204172326912.png)

![image-20220417232636836](https://gitee.com/bright_xu/blog-image/raw/master/202204172326887.png)

![image-20220417232657483](https://gitee.com/bright_xu/blog-image/raw/master/202204172326600.png)

## 六. 任务二

任务二在任务一的基础上，需要添加容忍链路故障的功能，因为链路故障是需要先感知然后重新计算的，所以可以将功能添加到`network_awareness`模块中，具体需要添加的函数有：

- 删除流表项。由于链路发生故障，某条链路无法使用，因此曾经匹配该端口的流表项已经不再有效，需要删除。
- 控制器捕捉链路故障。链路状态改变时，链路关联的端口状态也会变化，从而产生端口状态改变的事件，即 `EventOFPPortStatus` ，通过将此事件与设计的处理函数绑定在一起，就可以获取状态改变的信息， 执行相应的处理。
- 链路状态改变的处理函数。获取到了链路状态改变的原因，就可以对其进行相应的处理。如果是链路发生故障，则需要在拓扑图中删除相应的链路link，并且把当前最短路径中的包含这条链路的路径重新计算一遍。如果是链路恢复，则只需要重新计算最短路径即可。

### 关键代码讲解：

#### 删除流表项

与向交换机中增加流表的 OFPFC_ADD 命令不同， OFPFC_DELETE 消息用于删除交换机中符合匹配项的所 有流表。

删除交换机的流表项可以参照 `add_flow()` 函数，即可编写出`delete_flow() `函数。这里可以调用RYU自带的`parser.OFPFlowMod`函数，对比`add_flow()` 函数，最主要的差别即为将内部的变量command变成`ofproto.OFPFC_DELETE`，代表流表删除。

```python
	def delete_flow(self, datapath):
    	ofproto = datapath.ofproto
    	parser = datapath.ofproto_parser
    	inst =[parser.OFPInstructionActions(ofproto.OFPFC_APPLY_ACTIONS,actions)]
    	mod = parser.OFPFlowMod(
        	datapath=datapath, 
        	out_port=ofproto.OFPP_ANY,
        	out_group=ofproto.OFPG_ANY,
        	command=ofproto.OFPFC_DELETE,
        	match=None, instructions=inst)
    	datapath.send_msg(mod)
```

#### 控制器处理链路

这个函数封装了控制器处理链路的过程，传入的参数是path，也就是最短路径。由于此时链路已经发生改变，因此曾经的流表已经不再适用，需要删除。其实只需要精确地将涉及到改变的链路进行删除就可以，这里为了方便，我设置的是将所有流表全部删除，因此程序如下：

```python
    def get_portstatus(self, path):
        for dpid in path:
            dp = self.datapath_info[dpid]
            self.delete_flow(dp)

            ofp = dp.ofproto
            parser = dp.ofproto_parser
            match = parser.OFPMatch()
            actions = [parser.OFPActionOutput(ofp.OFPP_CONTROLLER, ofp.OFPCML_NO_BUFFER)]
            self.add_flow(dp, 0, match, actions)
```

#### 链路状态改变的处理函数

这里需要用到装饰器，来确定触发处理函数的条件，这里的事件当然就是链路状态改变。需要注意的是，我们这里需要分情况讨论，对链路故障和链路恢复进行不同响应。

- 如果是链路发生故障，则需要在拓扑图中删除相应的链路link，然后删除流表项，并且把当前最短路径中的包含这条链路的路径重新计算一遍。需要注意的一点细节是，因为链路是双向的，因此我们第一遍删除边edge以后，第二遍其实就找不到了，不需要再重复删除。
- 如果是链路恢复，则只需要删除流表项，重新计算最短路径即可。

这里因为二者都要重新计算最短路径，所以我将计算最短路径的步骤放在了获取拓扑的函数里，故这里没有体现。

```python
    @set_ev_cls(ofp_event.EventOFPPortStatus, MAIN_DISPATCHER)
    def port_status_handle(self,ev):
        msg = ev.msg
        dp = msg.datapath
        dpid = dp.id
        ofp = dp.ofproto
        desc = msg.desc
        port_no = desc.port_no
        state = desc.state

        if msg.reason == ofp.OFPPR_MODIFY:
            if state == ofp.OFPPS_LINK_DOWN:
                # remove the link
                next_switch = None
                for switch in self.link_info[dpid].keys():
                    if self.link_info[dpid][switch] == port_no:
                        next_switch = switch
                        break
                try:
                    self.topo_map.remove_edge(dpid, next_switch)
                except:
                    print('the link has been removed')
                # delete flow entry
                self.get_portstatus(self.path)

            elif state == ofp.OFPPS_LIVE:
                # delete flow entry
                self.get_portstatus(self.path)

        else:
            return
```



### 实验过程：

首先像任务一一样，我们运行拓扑图和Ryu控制器，先验证链路没有发生故障时，控制器根据时延选择的最短路径。因此先`SDC ping MIT`，查看RTT的值，然后断开s8和之间的链路，重新ping，查看链路故障后的最短路径和RTT，进行对比，如下图：

![image-20220418132030404](https://gitee.com/bright_xu/blog-image/raw/master/202204181320535.png)

可以看到，在初始状态时，RTT约为131ms，且选择的最短路径与实验一中相同，经过计算确实是该路径，如下图：

![image-20220418132516225](https://gitee.com/bright_xu/blog-image/raw/master/202204181325269.png)

s9 和 s8 之间的链路故障后，控制器根据新拓扑，重新计算时延最小路径， RTT 约 147ms ，且最短路径发生改变。经过手动计算检验，求出最短路径确实如此，如下图：

![image-20220418132725747](https://gitee.com/bright_xu/blog-image/raw/master/202204181327809.png)

接下来，又将s9 和 s8 之间的链路从故障中恢复，控制器重新计算时延最小路径，可以看到RTT又减小到原来的时间。如下图：

![image-20220418133156729](https://gitee.com/bright_xu/blog-image/raw/master/202204181331819.png)

最短路径也恢复成了曾经的路径，如下图：

![image-20220418133237406](https://gitee.com/bright_xu/blog-image/raw/master/202204181332460.png)

## 七. 附加题

> **ryu 默认的发现拓扑的方式，是对所有交换机的所有端口发送 LLDP 数据包，对于 Fat tree 等网络拓扑 来说，端口的数量是交换机数量的k倍，因此导致了很多资源的消耗。请思考是否可以对拓扑发现机制进 行改进，让控制器发送的 LLDP 数据包数量和交换机的数量相同?**

指导书中在讲述LLDP原理时用到了一张图，讲到LLDP负载被封装在以太网帧中，结构如下图，其中深灰色的即为LLDP负载，Chassis ID TLV, Port ID TLV和Time to live TLV三个是强制字段，分别代表交换机标识符（在局域网中是独一无二的），端口号和TTL。

![img](https://gitee.com/bright_xu/blog-image/raw/master/202204181535569.png)

我们可以想到资源消耗的主要原因是控制器对交换机的所有端口都发送了LLDP数据包，但实际上可以想办法改进，让控制器只对某个交换机发送一次LLDP数据包，然后再让交换机把这个包逐个端口转发。这里的关键是要把端口号port ID和某个数据一一映射。

为了实现这个目标，可以在LLDP数据包从交换机端口转发出去的时候，将这个以太网数据包的源MAC地址替换成为这个端口的MAC地址，而控制器在早先的配置阶段已经获得了关于交换机的端口的所有信息，所以对控制器来说，MAC地址和交换机的端口号是一一对应的。

因此改进方案可以分为以下几步：

1. 更新控制器的`LLDP PacketOut`消息数量，由一个端口一个，改为一个交换机一个`PacketOut`消息，LLDP 数据包负载中的域`Port ID TLV`值置为零；

2. 控制器向流表下发一条规则：所有从端口Controller接收到的LLDP数据包，依次将其源MAC地址置为端口MAC地址，然后从相应的端口转发出去。这里要注意的是需要删除原来的以端口主导的相关代码。

3. 更新控制器的`PacketIn`消息处理机制，根据LLDP数据包的来源，可以得到目的交换机，目的端口，通过解析LLDP数据包，得到源MAC和源交换机，通过源MAC地址查找对应的端口号；

这样，就可以大大减少控制器集中控制的资源消耗，对于每一个交换机只需要发送一个LLDP数据包即可。

## 八. 源代码

### 实验示例：

求最少跳数路径的程序`shortest_hop_path.py`：

```python
from ryu.base import app_manager
from ryu.ofproto import ofproto_v1_3
from ryu.controller import ofp_event
from ryu.controller.handler import MAIN_DISPATCHER, CONFIG_DISPATCHER
from ryu.controller.handler import set_ev_cls
from ryu.topology.api import get_switch, get_link
from ryu.topology import event
from ryu.lib.packet import packet
from ryu.lib.packet import ethernet
 
import networkx as nx
 
class shortest_hop_path(app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]
 
    def __init__(self, *args, **kwargs):
        super(shortest_hop_path, self).__init__(*args, **kwargs)
        self.G = nx.DiGraph()
        # 作为get_switch()和get_link()方法的参数传入
        self.topology_api_app = self
 
    # 添加流表项的方法
    def add_flow(self, datapath, priority, match, actions):
        ofp = datapath.ofproto
        ofp_parser = datapath.ofproto_parser
        command = ofp.OFPFC_ADD
        inst = [ofp_parser.OFPInstructionActions(ofp.OFPIT_APPLY_ACTIONS, actions)]
        req = ofp_parser.OFPFlowMod(datapath=datapath, command=command, priority=priority, match=match, instructions=inst)
        datapath.send_msg(req)
 
    # 当控制器和交换机开始的握手动作完成后，进行table-miss(默认流表)的添加
    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_features_handler(self, ev):
        msg = ev.msg
        datapath = msg.datapath
        ofp = datapath.ofproto
        ofp_parser = datapath.ofproto_parser
 
        # add table-miss
        match = ofp_parser.OFPMatch()
        actions = [ofp_parser.OFPActionOutput(ofp.OFPP_CONTROLLER, ofp.OFPCML_NO_BUFFER)]
        self.add_flow(datapath=datapath, priority=0, match=match, actions=actions)
 
    @set_ev_cls(event.EventSwitchEnter)
    def get_topo(self, ev):
        switch_list = get_switch(self.topology_api_app)
        switches = []
        # 得到每个设备的id，并写入图中作为图的节点
        for switch in switch_list:
            switches.append(switch.dp.id)
        self.G.add_nodes_from(switches)
 
        link_list = get_link(self.topology_api_app)
        links = []
        # 将得到的链路的信息作为边写入图中
        for link in link_list:
            links.append((link.src.dpid, link.dst.dpid, {'attr_dict': {'port': link.src.port_no}}))
        self.G.add_edges_from(links)
 
        for link in link_list:
            links.append((link.dst.dpid, link.src.dpid, {'attr_dict': {'port': link.dst.port_no}}))
        self.G.add_edges_from(links)
 
    def get_out_port(self, datapath, src, dst, in_port):
        dpid = datapath.id
 
        # 开始时，各个主机可能在图中不存在，因为开始ryu只获取了交换机的dpid，并不知道各主机的信息，
        # 所以需要将主机存入图中
        if src not in self.G:
            self.G.add_node(src)
            self.G.add_edge(dpid, src, attr_dict={'port': in_port})
            self.G.add_edge(src, dpid)
 
        if dst in self.G:
            path = nx.shortest_path(self.G, src, dst)
            next_hop = path[path.index(dpid) + 1]
            out_port = self.G[dpid][next_hop]['attr_dict']['port']
            print(path)
        else:
            out_port = datapath.ofproto.OFPP_FLOOD
        return out_port
 
    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
    def packet_in_handler(self, ev):
        msg = ev.msg
        datapath = msg.datapath
        ofp = datapath.ofproto
        ofp_parser = datapath.ofproto_parser
 
        dpid = datapath.id
        in_port = msg.match['in_port']
 
        pkt = packet.Packet(msg.data)
        eth = pkt.get_protocols(ethernet.ethernet)[0]
 
        dst = eth.dst
        src = eth.src
 
        out_port = self.get_out_port(datapath, src, dst, in_port)
        actions = [ofp_parser.OFPActionOutput(out_port)]
 
        # 如果执行的动作不是flood，那么此时应该依据流表项进行转发操作，所以需要添加流表到交换机
        if out_port != ofp.OFPP_FLOOD:
            match = ofp_parser.OFPMatch(in_port=in_port, eth_dst=dst, eth_src=src)
            self.add_flow(datapath=datapath, priority=1, match=match, actions=actions)
 
        data = None
        if msg.buffer_id == ofp.OFP_NO_BUFFER:
            data = msg.data
        # 控制器指导执行的命令
        out = ofp_parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,
                                      in_port=in_port, actions=actions, data=data)
        datapath.send_msg(out)
```

### 任务一：

#### network_awareness.py

任务一的 `network_awareness.py` 程序如下：

```python
from ryu.base import app_manager
from ryu.base.app_manager import lookup_service_brick
from ryu.ofproto import ofproto_v1_3
from ryu.controller.handler import set_ev_cls
from ryu.controller.handler import MAIN_DISPATCHER, CONFIG_DISPATCHER, DEAD_DISPATCHER
from ryu.controller import ofp_event
from ryu.lib.packet import packet
from ryu.lib.packet import ethernet, arp
from ryu.lib import hub
from ryu.topology import event
from ryu.topology.api import get_host, get_link, get_switch
from ryu.topology.switches import LLDPPacket

import networkx as nx
import copy
import time

GET_TOPOLOGY_INTERVAL = 2
SEND_ECHO_REQUEST_INTERVAL = .05
GET_DELAY_INTERVAL = 2

class NetworkAwareness(app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]

    def __init__(self, *args, **kwargs):
        super(NetworkAwareness, self).__init__(*args, **kwargs)
        self.switch_info = {}  # dpid: datapath
        self.link_info = {}  # (s1, s2): s1.port
        self.port_link={} # s1,port:s1,s2
        self.port_info = {}  # dpid: (ports linked hosts)

        # save the topo_map using networkx
        self.topo_map = nx.Graph()

        # the thread to get the topo
        self.topo_thread = hub.spawn(self._get_topology)

        # the thread to send a echo packet
        self.echo_thread = hub.spawn(self.send_echo_request)
        
        self.datapath = {}
        self.echo_delay = {}
        self.lldp_delay = {}
        self.switches = None
        self.network_aware = None

        self.weight = 'delay'

    def add_flow(self, datapath, priority, match, actions):
        dp = datapath
        ofp = dp.ofproto
        parser = dp.ofproto_parser
        inst = [parser.OFPInstructionActions(ofp.OFPIT_APPLY_ACTIONS, actions)]
        mod = parser.OFPFlowMod(datapath=dp, priority=priority, match=match, instructions=inst)
        dp.send_msg(mod)
    
    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
    def packet_in_handler(self, ev):
        msg = ev.msg
        try:
            dp = msg.datapath
            src_dpid,src_port = LLDPPacket.lldp_parse(msg.data)
            dpid = dp.id
            self.link_info.setdefault(dpid,{})
            self.datapath[dpid] = dp
            if self.switches is None:
                self.switches = lookup_service_brick("switches")
            
            for port in self.switches.ports.keys():
                if src_dpid == port.dpid and src_port == port.port_no:
                    port_data = self.switches.ports[port]
                    timestamp = port_data.timestamp
                    if timestamp:
                        lldpdelay = time.time()-timestamp
                        # calculate the lldp delay
                        self.lldp_delay[(src_dpid, dpid)]=lldpdelay
        except LLDPPacket.LLDPUnknownFormat as e: 
            return
    
    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_features_handler(self, ev):
        msg = ev.msg
        dp = msg.datapath
        ofp = dp.ofproto
        parser = dp.ofproto_parser

        match = parser.OFPMatch()
        actions = [parser.OFPActionOutput(ofp.OFPP_CONTROLLER, ofp.OFPCML_NO_BUFFER)]
        self.add_flow(dp, 0, match, actions)
    
    @set_ev_cls(ofp_event.EventOFPStateChange, [MAIN_DISPATCHER, DEAD_DISPATCHER])
    def state_change_handler(self, ev):
        dp = ev.datapath
        dpid = dp.id
        
        if ev.state == MAIN_DISPATCHER:
            self.switch_info[dpid] = dp

        if ev.state == DEAD_DISPATCHER:
            del self.switch_info[dpid]
            
    def _get_topology(self):
        _hosts, _switches, _links = None, None, None
        
        while True:
            hosts = get_host(self)
            switches = get_switch(self)
            links = get_link(self)

            # update topo_map when topology change
            if [str(x) for x in hosts] == _hosts and [str(x) for x in switches] == _switches and [str(x) for x in links] == _links:
                continue
            _hosts, _switches, _links = [str(x) for x in hosts], [str(x) for x in switches], [str(x) for x in links]

            for switch in switches:
                self.port_info.setdefault(switch.dp.id, set())
                # record all ports
                for port in switch.ports:
                    self.port_info[switch.dp.id].add(port.port_no)

            for host in hosts:
                # take one ipv4 address as host id
                if host.ipv4:
                    self.link_info[host.port.dpid][host.ipv4[0]] = host.port.port_no
                    self.topo_map.add_edge(host.ipv4[0],host.port.dpid,is_Host=True)
            
            for link in links:
                # delete ports linked switches
                self.port_info[link.src.dpid].discard(link.src.port_no)
                self.port_info[link.dst.dpid].discard(link.dst.port_no)

                # s1 -> s2: s1.port, s2 -> s1: s2.port
                self.port_link[(link.src.dpid,link.src.port_no)] = (link.src.dpid, link.dst.dpid)
                self.port_link[(link.dst.dpid,link.dst.port_no)] = (link.dst.dpid, link.src.dpid)

                self.link_info[link.src.dpid][link.dst.dpid] = link.src.port_no
                self.link_info[link.dst.dpid][link.src.dpid] = link.dst.port_no

                # caculate the link delay
                delay = self.get_delay(link.src.dpid,link.dst.dpid)
                self.topo_map.add_edge(link.src.dpid, link.dst.dpid, delay=delay, is_Host=False)

            if self.weight == 'delay':
                self.show_topo_map()
            hub.sleep(GET_TOPOLOGY_INTERVAL)

    def shortest_path(self, src, dst, weight='delay'):
        try:
            # call the function to find the shortest path
            paths = nx.shortest_path(self.topo_map, src, dst, weight='delay')
            return paths
        except:
            self.logger.info('host not find/no path')

    def show_topo_map(self):
        self.logger.info('topo map:')
        self.logger.info('{:^10s}  ->  {:^10s}'.format('node', 'node'))
        for src, dst in self.topo_map.edges:
            self.logger.info('{:^10s}      {:^10s}'.format(str(src), str(dst)))
        self.logger.info('\n')

    def send_echo_request(self):
        while True:
            for datapath in self.datapath.values():
                parser = datapath.ofproto_parser
                data = b"%.6f" % time.time()
                echo_req = parser.OFPEchoRequest(datapath,data)
                
                datapath.send_msg(echo_req)
            hub.sleep(SEND_ECHO_REQUEST_INTERVAL)
    
    @set_ev_cls(ofp_event.EventOFPEchoReply, MAIN_DISPATCHER)
    def echo_reply_handler(self,ev):
        # calculate the echo packet delay
        echodelay = time.time()-eval(ev.msg.data)
        self.echo_delay[ev.msg.datapath.id] = echodelay
    
    def get_delay(self,src,dst):
        try:
            sd_lldpdelay = self.lldp_delay[(src,dst)]
            ds_lldpdelay = self.lldp_delay[(dst,src)]
            src_echodelay = self.echo_delay[src]
            dst_echodelay = self.echo_delay[dst]

            # calculate the delay according to the formula
            delay = (sd_lldpdelay+ds_lldpdelay-src_echodelay-dst_echodelay)/2

            # don't care about anything less than zero
            if delay<0:
                delay = 0
            return delay
        except:
            return float('inf')
```

#### shortest_forward.py

任务一的`shortest_forward.py`程序如下：

```python
# ryu-manager shortest_forward.py --observe-links
from ryu.base import app_manager
from ryu.controller import ofp_event
from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER, DEAD_DISPATCHER, HANDSHAKE_DISPATCHER
from ryu.controller.handler import set_ev_cls
from ryu.ofproto import ofproto_v1_3
from ryu.lib.packet import packet
from ryu.lib.packet import ethernet, arp, ipv4
from ryu.controller import ofp_event
from ryu.topology import event

from network_awareness import NetworkAwareness
import networkx as nx
import time
ETHERNET = ethernet.ethernet.__name__
ETHERNET_MULTICAST = "ff:ff:ff:ff:ff:ff"
ARP = arp.arp.__name__
class ShortestForward(app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]
    _CONTEXTS = {
        'network_awareness': NetworkAwareness
    }

    def __init__(self, *args, **kwargs):
        super(ShortestForward, self).__init__(*args, **kwargs)
        self.network_awareness = kwargs['network_awareness']
        self.mac_to_port = {}
        self.sw = {}
        self.host_port = {}
        self.path=None

    def add_flow(self, datapath, priority, match, actions, idle_timeout=0, hard_timeout=0):
        dp = datapath
        ofp = dp.ofproto
        parser = dp.ofproto_parser

        inst = [parser.OFPInstructionActions(ofp.OFPIT_APPLY_ACTIONS, actions)]
        mod = parser.OFPFlowMod(
            datapath=dp, priority=priority,
            idle_timeout=idle_timeout,
            hard_timeout=hard_timeout,
            match=match, instructions=inst)
        dp.send_msg(mod)

    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
    def packet_in_handler(self, ev):
        msg = ev.msg
        dp = msg.datapath
        ofp = dp.ofproto
        parser = dp.ofproto_parser

        dpid = dp.id
        in_port = msg.match['in_port']

        pkt = packet.Packet(msg.data)
        eth_pkt = pkt.get_protocol(ethernet.ethernet)
        arp_pkt = pkt.get_protocol(arp.arp)
        ipv4_pkt = pkt.get_protocol(ipv4.ipv4)

        pkt_type = eth_pkt.ethertype
        self.sw.setdefault(dpid,{})
        self.host_port.setdefault(dpid,{})
        # layer 2 self-learning
        dst_mac = eth_pkt.dst
        src_mac = eth_pkt.src
        self.sw[dpid].setdefault(src_mac,{})
        self.mac_to_port.setdefault(dpid,{})
        
        if isinstance(arp_pkt, arp.arp):
            self.handle_arp(msg, in_port, dst_mac,src_mac, pkt,arp_pkt)

        if isinstance(ipv4_pkt, ipv4.ipv4):
            self.handle_ipv4(msg, ipv4_pkt, pkt_type)
        
    def mac_learning(self,dpid,src,in_port):
        self.mac_to_port.setdefault(dpid,{})

        if src in self.mac_to_port[dpid]:
            if in_port != self.mac_to_port[dpid][src]:
                return False
        else:
            self.mac_to_port[dpid][src] = in_port
            return True

    def handle_arp(self, msg, in_port, dst,src, pkt, arp_pkt):
        dp = msg.datapath
        ofp = dp.ofproto
        parser = dp.ofproto_parser
        dpid = dp.id

        host = True
        for temp in self.network_awareness.link_info[dpid]:            
            if in_port == self.network_awareness.link_info[dpid][temp]:
                host = False
                break
        if host:
            arp_src_ip = arp_pkt.src_ip
            self.host_port[dpid][arp_src_ip] = in_port

        if dst in self.mac_to_port[dpid]:
            out_port = self.mac_to_port[dpid][dst]
        else:
            if self.mac_learning(dpid,src,in_port) is False:
                out_port = ofp.OFPPC_NO_RECV
            else:
                out_port = ofp.OFPP_FLOOD

        actions = [parser.OFPActionOutput(out_port)]

        if out_port != ofp.OFPP_FLOOD:
            match=parser.OFPMatch(in_port=in_port,eth_dst=dst,eth_src=src)
            self.add_flow(dp,1,match,actions)
        
        data = None
        if msg.buffer_id == ofp.OFP_NO_BUFFER:
            data = msg.data
	    
        out=parser.OFPPacketOut(datapath=dp, buffer_id=msg.buffer_id, in_port=in_port, actions=actions, data=data)
        dp.send_msg(out)

    def handle_ipv4(self, msg, ipv4_pkt, pkt_type):
        parser = msg.datapath.ofproto_parser
        src_ip = ipv4_pkt.src
        dst_ip = ipv4_pkt.dst
        
        flag = False
        for dpid in self.host_port.keys():
            for ip in self.host_port[dpid].keys():
                if ip == src_ip:
                    src_dpid = dpid
                    flag = True
                    break
            if flag:
                break
        
        flag1 = False
        for dpid in self.host_port.keys():
            for ip in self.host_port[dpid].keys():
                if ip == dst_ip:
                    dst_dpid = dpid
                    flag1 = True
                    break
            if flag1:
                break
        
        dpid_path = self.network_awareness.shortest_path(src_dpid, dst_dpid,weight='delay')
        if not dpid_path:
            return

        self.path=dpid_path
        # get port path:  h1 -> in_port, s1, out_port -> h2
        port_path = []
        for i in range(0, len(dpid_path)):
            if i==0:
                in_port = self.host_port[src_dpid][src_ip]
                out_port = self.network_awareness.link_info[dpid_path[0]][dpid_path[1]]
            elif i==len(dpid_path)-1:
                in_port = self.network_awareness.link_info[dpid_path[i]][dpid_path[i-1]]
                out_port = self.host_port[dst_dpid][dst_ip]
            else:
                in_port = self.network_awareness.link_info[dpid_path[i]][dpid_path[i - 1]]
                out_port = self.network_awareness.link_info[dpid_path[i]][dpid_path[i + 1]]

            port_path.append((in_port, dpid_path[i], out_port))

        #print(port_path)
        self.show_path(src_ip, dst_ip, port_path)

        # send flow mod
        for node in port_path:
            in_port, dpid, out_port = node
            self.send_flow_mod(parser, dpid, pkt_type, src_ip, dst_ip, in_port, out_port)
            self.send_flow_mod(parser, dpid, pkt_type, dst_ip, src_ip, out_port, in_port)

        # send packet_out
        _, dpid, out_port = port_path[-1]
        dp = self.network_awareness.switch_info[dpid]
        actions = [parser.OFPActionOutput(out_port)]
        out = parser.OFPPacketOut(
            datapath=dp, buffer_id=msg.buffer_id, in_port=in_port, actions=actions, data=msg.data)
        dp.send_msg(out)

    def send_flow_mod(self, parser, dpid, pkt_type, src_ip, dst_ip, in_port, out_port):
        dp = self.network_awareness.switch_info[dpid]
        match = parser.OFPMatch(
            in_port=in_port, eth_type=pkt_type, ipv4_src=src_ip, ipv4_dst=dst_ip)
        actions = [parser.OFPActionOutput(out_port)]
        self.add_flow(dp, 1, match, actions, 10, 30)

    def show_path(self, src, dst, port_path):
        self.logger.info('path: {} -> {}'.format(src, dst))
        path = src + ' -> '
        for node in port_path:
            path += '{}:s{}:{}'.format(*node) + ' -> '
        path += dst
        self.logger.info(path)
```

### 任务二：

任务二中，`shortest_forward.py`与任务一未作出改变，因此不再贴出。

任务二的 `network_awareness.py` 程序如下：

```python
from ryu.base import app_manager
from ryu.base.app_manager import lookup_service_brick
from ryu.ofproto import ofproto_v1_3
from ryu.controller.handler import set_ev_cls
from ryu.controller.handler import MAIN_DISPATCHER, CONFIG_DISPATCHER, DEAD_DISPATCHER
from ryu.controller import ofp_event
from ryu.lib.packet import packet
from ryu.lib.packet import ethernet, arp
from ryu.lib import hub
from ryu.topology import event
from ryu.topology.api import get_host, get_link, get_switch
from ryu.topology.switches import LLDPPacket

import networkx as nx
import copy
import time

GET_TOPOLOGY_INTERVAL = 2
SEND_ECHO_REQUEST_INTERVAL = .05
GET_DELAY_INTERVAL = 2

class NetworkAwareness(app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]

    def __init__(self, *args, **kwargs):
        super(NetworkAwareness, self).__init__(*args, **kwargs)
        self.switch_info = {}  # dpid: datapath
        self.link_info = {}  # (s1, s2): s1.port
        self.port_link={} # s1,port:s1,s2
        self.port_info = {}  # dpid: (ports linked hosts)
        self.topo_map = nx.Graph()
        self.topo_thread = hub.spawn(self._get_topology)
        self.echo_thread = hub.spawn(self.send_echo_request)
        self.datapath = {}
        self.echo_delay = {}
        self.lldp_delay = {}
        self.datapath_info = {}
        self.path = {}
        self.switches = None
        self.weight = 'delay'

    def add_flow(self, datapath, priority, match, actions):
        dp = datapath
        ofp = dp.ofproto
        parser = dp.ofproto_parser
        inst = [parser.OFPInstructionActions(ofp.OFPIT_APPLY_ACTIONS, actions)]
        mod = parser.OFPFlowMod(datapath=dp, priority=priority, match=match, instructions=inst)
        dp.send_msg(mod)
        
    def delete_flow(self, datapath):
    	ofproto = datapath.ofproto
    	parser = datapath.ofproto_parser
    	inst =[parser.OFPInstructionActions(ofproto.OFPFC_APPLY_ACTIONS,actions)]
    	mod = parser.OFPFlowMod(
        	datapath=datapath, 
        	out_port=ofproto.OFPP_ANY,
        	out_group=ofproto.OFPG_ANY,
        	command=ofproto.OFPFC_DELETE,
        	match=None, instructions=inst)
    	datapath.send_msg(mod)
        
    @set_ev_cls(ofp_event.EventOFPPortStatus, MAIN_DISPATCHER)
    def port_status_handle(self,ev):
        msg = ev.msg
        dp = msg.datapath
        dpid = dp.id
        ofp = dp.ofproto
        desc = msg.desc
        port_no = desc.port_no
        state = desc.state

        if msg.reason == ofp.OFPPR_MODIFY:
            if state == ofp.OFPPS_LINK_DOWN:
                #remove the link
                next_switch = None
                for switch in self.link_info[dpid].keys():
                    if self.link_info[dpid][switch] == port_no:
                        next_switch = switch
                        break
                try:
                    self.topo_map.remove_edge(dpid, next_switch)
                except:
                    print('remove the link')

                # delete
                self.get_portstatus(self.path)

            elif state == ofp.OFPPS_LIVE:
                print('recover the link')
                # delete flow entry
                self.get_portstatus(self.path)
        else:
            return
    
    def get_portstatus(self,path):
        #print(self.switch_info)
        print(path)
        for dpid in path:
            dp = self.datapath_info[dpid]
            self.delete_flow(dp)

            ofp = dp.ofproto
            parser = dp.ofproto_parser
            match = parser.OFPMatch()
            actions = [parser.OFPActionOutput(ofp.OFPP_CONTROLLER, ofp.OFPCML_NO_BUFFER)]
            self.add_flow(dp, 0, match, actions)

    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
    def packet_in_handler(self, ev):
        msg = ev.msg
        try:
            dp = msg.datapath
            src_dpid,src_port = LLDPPacket.lldp_parse(msg.data)
            dpid = dp.id
            self.datapath_info[dpid] = dp
            self.link_info.setdefault(dpid,{})
            self.datapath[dpid] = dp
            if self.switches is None:
                self.switches = lookup_service_brick("switches")
            
            for port in self.switches.ports.keys():
                if src_dpid == port.dpid and src_port == port.port_no:
                    port_data = self.switches.ports[port]
                    timestamp = port_data.timestamp
                    if timestamp:
                        lldpdelay = time.time()-timestamp
                        #print(lldpdelay)
                        self.lldp_delay[(src_dpid, dpid)]=lldpdelay
        except LLDPPacket.LLDPUnknownFormat as e: 
            return
    
    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_features_handler(self, ev):
        msg = ev.msg
        dp = msg.datapath
        ofp = dp.ofproto
        parser = dp.ofproto_parser

        match = parser.OFPMatch()
        actions = [parser.OFPActionOutput(ofp.OFPP_CONTROLLER, ofp.OFPCML_NO_BUFFER)]
        self.add_flow(dp, 0, match, actions)
    
    @set_ev_cls(ofp_event.EventOFPStateChange, [MAIN_DISPATCHER, DEAD_DISPATCHER])
    def state_change_handler(self, ev):
        dp = ev.datapath
        dpid = dp.id
        
        if ev.state == MAIN_DISPATCHER:
            self.switch_info[dpid] = dp

        if ev.state == DEAD_DISPATCHER:
            del self.switch_info[dpid]
            
    def _get_topology(self):
        _hosts, _switches, _links = None, None, None
        
        while True:
            hosts = get_host(self)
            switches = get_switch(self)
            links = get_link(self)

            # update topo_map when topology change
            if [str(x) for x in hosts] == _hosts and [str(x) for x in switches] == _switches and [str(x) for x in links] == _links:
                continue
            _hosts, _switches, _links = [str(x) for x in hosts], [str(x) for x in switches], [str(x) for x in links]

            for switch in switches:
                self.port_info.setdefault(switch.dp.id, set())
                # record all ports
                for port in switch.ports:
                    self.port_info[switch.dp.id].add(port.port_no)

            for host in hosts:
                # take one ipv4 address as host id
                if host.ipv4:
                    self.link_info[host.port.dpid][host.ipv4[0]] = host.port.port_no
                    #self.topo_map.add_edge(host.ipv4[0],host.port.dpid,is_Host=True)
            
            for link in links:
                # delete ports linked switches
                self.port_info[link.src.dpid].discard(link.src.port_no)
                self.port_info[link.dst.dpid].discard(link.dst.port_no)

                # s1 -> s2: s1.port, s2 -> s1: s2.port
                self.port_link[(link.src.dpid,link.src.port_no)]=(link.src.dpid, link.dst.dpid)
                self.port_link[(link.dst.dpid,link.dst.port_no)] = (link.dst.dpid, link.src.dpid)

                self.link_info[link.src.dpid][link.dst.dpid] = link.src.port_no
                self.link_info[link.dst.dpid][link.src.dpid] = link.dst.port_no
                delay = self.get_delay(link.src.dpid,link.dst.dpid)
                self.topo_map.add_edge(link.src.dpid, link.dst.dpid,delay=delay,is_Host=False)

            if self.weight == 'delay':
                self.show_topo_map()
            hub.sleep(GET_TOPOLOGY_INTERVAL)

    def shortest_path(self, src, dst, weight='delay'):
        try:
            paths = nx.shortest_path(self.topo_map, src, dst, weight='delay')
            self.path = paths
            return paths
        except:
            self.logger.info('host not find/no path')

    def show_topo_map(self):
        self.logger.info('topo map:')
        self.logger.info('{:^10s}  ->  {:^10s}'.format('node', 'node'))
        for src, dst in self.topo_map.edges:
            self.logger.info('{:^10s}      {:^10s}'.format(str(src), str(dst)))
        self.logger.info('\n')
       
    def send_echo_request(self):
        while True:
            for datapath in self.datapath.values():
                parser = datapath.ofproto_parser
                data = b"%.6f" % time.time()
                echo_req = parser.OFPEchoRequest(datapath,data)
                datapath.send_msg(echo_req)
            hub.sleep(SEND_ECHO_REQUEST_INTERVAL)
    
    @set_ev_cls(ofp_event.EventOFPEchoReply, MAIN_DISPATCHER)
    def echo_reply_handler(self,ev):
        echodelay = time.time()-eval(ev.msg.data)
        self.echo_delay[ev.msg.datapath.id] = echodelay
    
    def get_delay(self,src,dst):
        try:
            sd_lldpdelay = self.lldp_delay[(src,dst)]
            ds_lldpdelay = self.lldp_delay[(dst,src)]
            src_echodelay = self.echo_delay[src]
            dst_echodelay = self.echo_delay[dst]

            delay = (sd_lldpdelay+ds_lldpdelay-src_echodelay-dst_echodelay)/2
            if delay<0:
                delay = 0
            return delay
        except:
            return float('inf')
```

